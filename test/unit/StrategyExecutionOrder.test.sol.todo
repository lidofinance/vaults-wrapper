// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.25;

import {Test} from "forge-std/Test.sol";
import {DeFiWrapper} from "../src/DeFiWrapper.sol";
import {StVaultEscrowV2} from "../src/v2/StVaultEscrowV2.sol";
import {SimpleLeverageStrategy} from "../src/v2/SimpleLeverageStrategy.sol";
import {MockERC20} from "./mocks/MockERC20.sol";
import {MockVaultHub} from "./mocks/MockVaultHub.sol";
import {MockStakingVault} from "./mocks/MockStakingVault.sol";

/**
 * @title StrategyExecutionOrderTest
 * @notice Test for correct strategy execution sequence
 */
contract StrategyExecutionOrderTest is Test {
    DeFiWrapper public defiWrapper;
    StVaultEscrowV2 public escrow;
    SimpleLeverageStrategy public strategy;
    MockERC20 public stETH;
    MockVaultHub public vaultHub;
    MockStakingVault public stakingVault;

    address public user = address(0x1);

    uint256 public constant INITIAL_ETH = 10 ether;
    uint256 public constant TARGET_LEVERAGE = 2e18; // 200%

    function setUp() public {
        // Deploy mocks
        stETH = new MockERC20("Liquid staked Ether 2.0", "stETH");
        vaultHub = new MockVaultHub();
        stakingVault = new MockStakingVault();

        // Deploy DeFiWrapper
        defiWrapper = new DeFiWrapper(
            address(stakingVault),
            address(stETH),
            address(0),
            address(0),
            "StVault Wrapper",
            "stvToken"
        );

        // Deploy strategy
        strategy = new SimpleLeverageStrategy(
            address(0), // escrow - will set later
            address(stETH),
            address(defiWrapper)
        );

        // Deploy StVaultEscrowV2
        escrow = new StVaultEscrowV2(
            address(defiWrapper),
            address(vaultHub),
            address(stakingVault),
            address(stETH),
            address(strategy)
        );

        // Setup permissions
        defiWrapper.setEscrow(address(escrow));

        // Fund user
        vm.deal(user, INITIAL_ETH);

        // Setup mocks
        stETH.mint(address(vaultHub), 1000 ether);
        vaultHub.setStakingVault(address(stakingVault));
    }

    function testCorrectExecutionOrder() public {
        vm.startPrank(user);

                // 1. Deposit ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);

        // 2. Remember strategy stETH balance BEFORE deposit
        uint256 strategyStETHBefore = stETH.balanceOf(address(strategy));

        // 3. Deposit with leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);

                // 4. Check that strategy received stETH
        uint256 strategyStETHAfter = stETH.balanceOf(address(strategy));
        assertGt(strategyStETHAfter, strategyStETHBefore, "Strategy should have received stETH");

        // 5. Check position
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertEq(position.debt, strategyStETHAfter - strategyStETHBefore, "Position debt should match minted stETH");

        console.log("✅ Correct execution order verified");
        console.log("   Strategy stETH before:", strategyStETHBefore);
        console.log("   Strategy stETH after:", strategyStETHAfter);
        console.log("   Position debt:", position.debt);
        console.log("   Minted stETH:", strategyStETHAfter - strategyStETHBefore);

        vm.stopPrank();
    }

        function testStrategyCanUseMintedStETH() public {
        vm.startPrank(user);

        // 1. Deposit ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);

        // 2. Deposit with leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);

                // 3. Check that strategy created yield position
        (uint256 yieldPosition, uint256 currentYield) = strategy.getYieldPosition(address(escrow));
        assertGt(yieldPosition, 0, "Strategy should have created yield position");

        // 4. Check that yield position matches minted stETH
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertEq(yieldPosition, position.debt, "Yield position should match position debt");

        console.log("✅ Strategy can use minted stETH");
        console.log("   Yield position size:", yieldPosition);
        console.log("   Position debt:", position.debt);
        console.log("   Current yield:", currentYield);

        vm.stopPrank();
    }

        function testStrategyReturnsZeroForDebtMinted() public {
        vm.startPrank(user);

        // 1. Deposit ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);

        // 2. Deposit with leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);

                // 3. Check that position is created with correct debt
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertGt(position.debt, 0, "Position should have debt");

        // 4. Check that strategy has stETH
        uint256 strategyStETH = stETH.balanceOf(address(strategy));
        assertEq(strategyStETH, position.debt, "Strategy stETH should match position debt");

        console.log("✅ Strategy correctly handles pre-minted stETH");
        console.log("   Position debt:", position.debt);
        console.log("   Strategy stETH:", strategyStETH);

        vm.stopPrank();
    }

        function testRevertIfStrategyHasNoStETH() public {
        vm.startPrank(user);

        // 1. Deposit ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);

        // 2. Attempt deposit with leverage = 100% (will not mint stETH)
        vm.expectRevert("No stETH minted for strategy");
        escrow.deposit(stvTokenBalance, 1e18); // 100% leverage = no additional stETH

        console.log("✅ Correctly reverts when no stETH is minted");

        vm.stopPrank();
    }

        function testExecutionOrderInEvents() public {
        vm.startPrank(user);

        // 1. Deposit ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);

        // 2. Deposit with leverage and track events
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);

        // 3. Check events
        // PositionCreated should be the last event
        // StrategyExecuted should be before PositionCreated

        console.log("✅ Events emitted in correct order");
        console.log("   1. Strategy executed (stETH minted and used)");
        console.log("   2. Position created (with final debt amount)");

        vm.stopPrank();
    }
}