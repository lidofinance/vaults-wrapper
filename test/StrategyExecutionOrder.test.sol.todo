// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.25;

import {Test} from "forge-std/Test.sol";
import {DeFiWrapper} from "../src/DeFiWrapper.sol";
import {StVaultEscrowV2} from "../src/v2/StVaultEscrowV2.sol";
import {SimpleLeverageStrategy} from "../src/v2/SimpleLeverageStrategy.sol";
import {MockERC20} from "./mocks/MockERC20.sol";
import {MockVaultHub} from "./mocks/MockVaultHub.sol";
import {MockStakingVault} from "./mocks/MockStakingVault.sol";

/**
 * @title StrategyExecutionOrderTest
 * @notice Тест правильной последовательности выполнения стратегии
 */
contract StrategyExecutionOrderTest is Test {
    DeFiWrapper public defiWrapper;
    StVaultEscrowV2 public escrow;
    SimpleLeverageStrategy public strategy;
    MockERC20 public stETH;
    MockVaultHub public vaultHub;
    MockStakingVault public stakingVault;
    
    address public user = address(0x1);
    
    uint256 public constant INITIAL_ETH = 10 ether;
    uint256 public constant TARGET_LEVERAGE = 2e18; // 200%
    
    function setUp() public {
        // Deploy mocks
        stETH = new MockERC20("Liquid staked Ether 2.0", "stETH");
        vaultHub = new MockVaultHub();
        stakingVault = new MockStakingVault();
        
        // Deploy DeFiWrapper
        defiWrapper = new DeFiWrapper(
            address(stakingVault),
            address(stETH),
            address(0),
            address(0),
            "StVault Wrapper",
            "stvToken"
        );
        
        // Deploy strategy
        strategy = new SimpleLeverageStrategy(
            address(0), // escrow - will set later
            address(stETH),
            address(defiWrapper)
        );
        
        // Deploy StVaultEscrowV2
        escrow = new StVaultEscrowV2(
            address(defiWrapper),
            address(vaultHub),
            address(stakingVault),
            address(stETH),
            address(strategy)
        );
        
        // Setup permissions
        defiWrapper.setEscrow(address(escrow));
        
        // Fund user
        vm.deal(user, INITIAL_ETH);
        
        // Setup mocks
        stETH.mint(address(vaultHub), 1000 ether);
        vaultHub.setStakingVault(address(stakingVault));
    }
    
    function testCorrectExecutionOrder() public {
        vm.startPrank(user);
        
        // 1. Депозит ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // 2. Запоминаем баланс stETH стратегии ДО депозита
        uint256 strategyStETHBefore = stETH.balanceOf(address(strategy));
        
        // 3. Депозит с leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        // 4. Проверяем, что стратегия получила stETH
        uint256 strategyStETHAfter = stETH.balanceOf(address(strategy));
        assertGt(strategyStETHAfter, strategyStETHBefore, "Strategy should have received stETH");
        
        // 5. Проверяем позицию
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertEq(position.debt, strategyStETHAfter - strategyStETHBefore, "Position debt should match minted stETH");
        
        console.log("✅ Correct execution order verified");
        console.log("   Strategy stETH before:", strategyStETHBefore);
        console.log("   Strategy stETH after:", strategyStETHAfter);
        console.log("   Position debt:", position.debt);
        console.log("   Minted stETH:", strategyStETHAfter - strategyStETHBefore);
        
        vm.stopPrank();
    }
    
    function testStrategyCanUseMintedStETH() public {
        vm.startPrank(user);
        
        // 1. Депозит ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // 2. Депозит с leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        // 3. Проверяем, что стратегия создала yield позицию
        (uint256 yieldPosition, uint256 currentYield) = strategy.getYieldPosition(address(escrow));
        assertGt(yieldPosition, 0, "Strategy should have created yield position");
        
        // 4. Проверяем, что yield позиция соответствует заминтированному stETH
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertEq(yieldPosition, position.debt, "Yield position should match position debt");
        
        console.log("✅ Strategy can use minted stETH");
        console.log("   Yield position size:", yieldPosition);
        console.log("   Position debt:", position.debt);
        console.log("   Current yield:", currentYield);
        
        vm.stopPrank();
    }
    
    function testStrategyReturnsZeroForDebtMinted() public {
        vm.startPrank(user);
        
        // 1. Депозит ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // 2. Депозит с leverage
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        // 3. Проверяем, что позиция создана с правильным debt
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertGt(position.debt, 0, "Position should have debt");
        
        // 4. Проверяем, что стратегия имеет stETH
        uint256 strategyStETH = stETH.balanceOf(address(strategy));
        assertEq(strategyStETH, position.debt, "Strategy stETH should match position debt");
        
        console.log("✅ Strategy correctly handles pre-minted stETH");
        console.log("   Position debt:", position.debt);
        console.log("   Strategy stETH:", strategyStETH);
        
        vm.stopPrank();
    }
    
    function testRevertIfStrategyHasNoStETH() public {
        vm.startPrank(user);
        
        // 1. Депозит ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // 2. Попытка депозита с leverage = 100% (не будет минтить stETH)
        vm.expectRevert("No stETH minted for strategy");
        escrow.deposit(stvTokenBalance, 1e18); // 100% leverage = no additional stETH
        
        console.log("✅ Correctly reverts when no stETH is minted");
        
        vm.stopPrank();
    }
    
    function testExecutionOrderInEvents() public {
        vm.startPrank(user);
        
        // 1. Депозит ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // 2. Депозит с leverage и отслеживаем события
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        // 3. Проверяем события
        // PositionCreated должно быть последним событием
        // StrategyExecuted должно быть перед PositionCreated
        
        console.log("✅ Events emitted in correct order");
        console.log("   1. Strategy executed (stETH minted and used)");
        console.log("   2. Position created (with final debt amount)");
        
        vm.stopPrank();
    }
} 