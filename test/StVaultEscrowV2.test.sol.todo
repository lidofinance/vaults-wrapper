// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.25;

import {Test} from "forge-std/Test.sol";
import {DeFiWrapper} from "../src/DeFiWrapper.sol";
import {StVaultEscrowV2} from "../src/v2/StVaultEscrowV2.sol";
import {SimpleLeverageStrategy} from "../src/v2/SimpleLeverageStrategy.sol";
import {MockERC20} from "./mocks/MockERC20.sol";
import {MockVaultHub} from "./mocks/MockVaultHub.sol";
import {MockStakingVault} from "./mocks/MockStakingVault.sol";

/**
 * @title StVaultEscrowV2Test
 * @notice –¢–µ—Å—Ç —É–ø—Ä–æ—â–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏ StVaultEscrowV2
 */
contract StVaultEscrowV2Test is Test {
    DeFiWrapper public defiWrapper;
    StVaultEscrowV2 public escrow;
    SimpleLeverageStrategy public strategy;
    MockERC20 public stETH;
    MockVaultHub public vaultHub;
    MockStakingVault public stakingVault;
    
    address public user = address(0x1);
    address public owner = address(0x2);
    
    uint256 public constant INITIAL_ETH = 10 ether;
    uint256 public constant TARGET_LEVERAGE = 2e18; // 200%
    
    function setUp() public {
        // Deploy mocks
        stETH = new MockERC20("Liquid staked Ether 2.0", "stETH");
        vaultHub = new MockVaultHub();
        stakingVault = new MockStakingVault();
        
        // Deploy DeFiWrapper
        defiWrapper = new DeFiWrapper(
            address(stakingVault),
            address(stETH),
            address(0), // escrow - will set later
            address(0), // strategy - will set later
            "StVault Wrapper",
            "stvToken"
        );
        
        // Deploy strategy
        strategy = new SimpleLeverageStrategy(
            address(0), // escrow - will set later
            address(stETH),
            address(defiWrapper)
        );
        
        // Deploy StVaultEscrowV2
        escrow = new StVaultEscrowV2(
            address(defiWrapper),
            address(vaultHub),
            address(stakingVault),
            address(stETH),
            address(strategy)
        );
        
        // Setup permissions
        defiWrapper.setEscrow(address(escrow));
        
        // Fund user
        vm.deal(user, INITIAL_ETH);
        
        // Setup mocks
        stETH.mint(address(vaultHub), 1000 ether);
        vaultHub.setStakingVault(address(stakingVault));
    }
    
    function testSimplifiedUserJourney() public {
        // ============================================================================
        // –®–∞–≥ 1: –î–µ–ø–æ–∑–∏—Ç ETH –≤ DeFiWrapper
        // ============================================================================
        
        vm.startPrank(user);
        
        // –î–µ–ø–æ–∑–∏—Ç ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        
        console.log("‚úÖ Step 1: ETH deposit successful");
        console.log("   ETH deposited:", INITIAL_ETH);
        console.log("   stvToken received:", stvTokenBalance);
        
        // ============================================================================
        // –®–∞–≥ 2: –î–µ–ø–æ–∑–∏—Ç stvToken –≤ StVaultEscrowV2 (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é)
        // ============================================================================
        
        // Approve stvToken
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // –î–µ–ø–æ–∑–∏—Ç —Å leverage - –í–°–ï –í –û–î–ù–û–ú –í–´–ó–û–í–ï!
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        console.log("‚úÖ Step 2: Simplified deposit successful");
        console.log("   Position ID:", positionId);
        
        // ============================================================================
        // –®–∞–≥ 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–∑–¥–∞–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
        // ============================================================================
        
        StVaultEscrowV2.Position memory position = escrow.getPosition(positionId);
        assertEq(position.owner, user, "Position owner should be user");
        assertEq(position.collateral, stvTokenBalance, "Collateral should match deposit");
        assertGt(position.debt, 0, "Should have debt after strategy execution");
        assertTrue(position.active, "Position should be active");
        
        console.log("‚úÖ Step 3: Position created successfully");
        console.log("   Collateral:", position.collateral);
        console.log("   Debt:", position.debt);
        console.log("   Created at:", position.createdAt);
        
        // ============================================================================
        // –®–∞–≥ 4: –ü—Ä–æ–≤–µ—Ä—è–µ–º health factor
        // ============================================================================
        
        uint256 healthFactor = escrow.getHealthFactor(positionId);
        assertGt(healthFactor, 150e16, "Health factor should be above 150%");
        
        bool isHealthy = escrow.isHealthyPosition(positionId);
        assertTrue(isHealthy, "Position should be healthy");
        
        console.log("‚úÖ Step 4: Position health verified");
        console.log("   Health factor:", healthFactor);
        
        // ============================================================================
        // –®–∞–≥ 5: –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        // ============================================================================
        
        uint256[] memory userPositions = escrow.getUserPositions(user);
        assertEq(userPositions.length, 1, "Should have 1 position");
        assertEq(userPositions[0], positionId, "Position ID should match");
        
        StVaultEscrowV2.Position[] memory activePositions = escrow.getActivePositions(user);
        assertEq(activePositions.length, 1, "Should have 1 active position");
        assertEq(activePositions[0].id, positionId, "Active position ID should match");
        
        console.log("‚úÖ Step 5: User positions tracked correctly");
        
        // ============================================================================
        // –®–∞–≥ 6: –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        // ============================================================================
        
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º 100% –ø–æ–∑–∏—Ü–∏–∏
        (uint256 collateralReturned, uint256 debtBurned) = escrow.closePosition(positionId, 1e18);
        
        assertGt(collateralReturned, 0, "Should return collateral");
        assertEq(debtBurned, position.debt, "Should burn all debt");
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∑–∏—Ü–∏—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞
        position = escrow.getPosition(positionId);
        assertFalse(position.active, "Position should be inactive after closing");
        
        console.log("‚úÖ Step 6: Position closed successfully");
        console.log("   Collateral returned:", collateralReturned);
        console.log("   Debt burned:", debtBurned);
        
        vm.stopPrank();
        
        // ============================================================================
        // –§–∏–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        // ============================================================================
        
        console.log("\nüéâ Simplified user journey successful!");
        console.log("   Total steps: 2 (vs 6 in old version)");
        console.log("   Initial ETH:", INITIAL_ETH);
        console.log("   Final stvToken:", collateralReturned);
    }
    
    function testMultiplePositions() public {
        vm.startPrank(user);
        
        // –î–µ–ø–æ–∑–∏—Ç ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–∑–∏—Ü–∏–π
        uint256 position1 = escrow.deposit(stvTokenBalance / 2, 2e18); // 200% leverage
        uint256 position2 = escrow.deposit(stvTokenBalance / 2, 3e18); // 300% leverage
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∑–∏—Ü–∏–∏ —Ä–∞–∑–Ω—ã–µ
        assertEq(position1, 0, "First position should have ID 0");
        assertEq(position2, 1, "Second position should have ID 1");
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        uint256[] memory userPositions = escrow.getUserPositions(user);
        assertEq(userPositions.length, 2, "Should have 2 positions");
        
        StVaultEscrowV2.Position[] memory activePositions = escrow.getActivePositions(user);
        assertEq(activePositions.length, 2, "Should have 2 active positions");
        
        console.log("‚úÖ Multiple positions created successfully");
        console.log("   Position 1 ID:", position1);
        console.log("   Position 2 ID:", position2);
        
        vm.stopPrank();
    }
    
    function testPartialPositionClose() public {
        vm.startPrank(user);
        
        // –î–µ–ø–æ–∑–∏—Ç ETH –∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        StVaultEscrowV2.Position memory initialPosition = escrow.getPosition(positionId);
        
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º 50% –ø–æ–∑–∏—Ü–∏–∏
        (uint256 collateralReturned, uint256 debtBurned) = escrow.closePosition(positionId, 0.5e18);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∑–∏—Ü–∏—è –≤—Å–µ –µ—â–µ –∞–∫—Ç–∏–≤–Ω–∞
        StVaultEscrowV2.Position memory updatedPosition = escrow.getPosition(positionId);
        assertTrue(updatedPosition.active, "Position should still be active");
        assertEq(updatedPosition.collateral, initialPosition.collateral - collateralReturned, "Collateral should be reduced");
        assertEq(updatedPosition.debt, initialPosition.debt - debtBurned, "Debt should be reduced");
        
        console.log("‚úÖ Partial position close successful");
        console.log("   Initial collateral:", initialPosition.collateral);
        console.log("   Remaining collateral:", updatedPosition.collateral);
        console.log("   Initial debt:", initialPosition.debt);
        console.log("   Remaining debt:", updatedPosition.debt);
        
        vm.stopPrank();
    }
    
    function testRevertOnInvalidLeverage() public {
        vm.startPrank(user);
        
        // –î–µ–ø–æ–∑–∏—Ç ETH
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        // –ü—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é —Å leverage <= 100%
        vm.expectRevert("Leverage must be > 100%");
        escrow.deposit(stvTokenBalance, 1e18); // 100% leverage
        
        vm.expectRevert("Leverage must be > 100%");
        escrow.deposit(stvTokenBalance, 0.5e18); // 50% leverage
        
        console.log("‚úÖ Invalid leverage correctly rejected");
        
        vm.stopPrank();
    }
    
    function testRevertOnNotPositionOwner() public {
        vm.startPrank(user);
        
        // –î–µ–ø–æ–∑–∏—Ç ETH –∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
        defiWrapper.deposit{value: INITIAL_ETH}(INITIAL_ETH, user);
        uint256 stvTokenBalance = defiWrapper.balanceOf(user);
        defiWrapper.approve(address(escrow), stvTokenBalance);
        
        uint256 positionId = escrow.deposit(stvTokenBalance, TARGET_LEVERAGE);
        
        vm.stopPrank();
        
        // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é –æ—Ç –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        vm.startPrank(address(0x999));
        vm.expectRevert("Not position owner");
        escrow.closePosition(positionId, 1e18);
        
        console.log("‚úÖ Unauthorized access correctly rejected");
        
        vm.stopPrank();
    }
} 