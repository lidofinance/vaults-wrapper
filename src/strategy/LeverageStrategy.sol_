// SPDX-License-Identifier: MIT
pragma solidity >=0.8.25;

import {IStrategy} from "../interfaces/IStrategy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IStETH} from "../interfaces/IStETH.sol";
import {WrapperC} from "../WrapperC.sol";
import {IVaultHub} from "../interfaces/IVaultHub.sol";
import {IDashboard} from "../interfaces/IDashboard.sol";
import {LenderMock} from 'src/mock/LenderMock.sol';
import {IWstETH} from "../interfaces/IWstETH.sol";

import {console} from "forge-std/console.sol";

contract LeverageStrategy is IStrategy {

    IERC20 public immutable STV_TOKEN;
    IStETH public immutable STETH;
    IWstETH public immutable WSTETH;
    LenderMock public immutable LENDER_MOCK;

    WrapperC public WRAPPER;

    uint256 public immutable LOOPS;

    struct UserPosition {
        address user;
        uint256 stvShares;
        uint256 stShares;
        uint256 borrowedEth;
    }

    mapping(address user => UserPosition) public userPositions;

    error InvalidWrapper();

    constructor(address _stETH, address _wstETH, address _aavePool, uint256 _loops) {
        STETH = IStETH(_stETH);
        WSTETH = IWstETH(_wstETH);
        LOOPS = _loops;
        LENDER_MOCK = new LenderMock(_stETH);
    }

    receive() external payable {}

    function initialize(address _wrapper) external {
        WRAPPER = WrapperC(payable(_wrapper));
    }

    function strategyId() external pure override returns (bytes32) {
        return keccak256("strategy.leverage.v1");
    }

    function getUserPosition(address _address) external view returns (UserPosition memory) {
        return userPositions[_address];
    }

    function execute(address _user, uint256 _stvShares) external {
        _onlyWrapper();

        console.log("\n---Execute start");

        uint256 _mintableStethShares = WRAPPER.mintableStethShares(address(this));

        UserPosition storage position = userPositions[_user];
        position.stvShares += _stvShares;
        position.stShares += _mintableStethShares;

        uint256 borrowedEth = 0;
        for (uint256 i = 0; i < LOOPS; i++) {
           
            WRAPPER.mintStethShares(_mintableStethShares);

            uint256 stethAmount = STETH.getPooledEthByShares(_mintableStethShares);
            STETH.approve(address(LENDER_MOCK), stethAmount);

            uint256 ethBefore = address(this).balance;

            // uint256 aToken = aave.supply(steth)
            LENDER_MOCK.borrow(stethAmount);
            // borrowedEth = weth().withdraw(weth);
            
            borrowedEth = address(this).balance - ethBefore;
            position.borrowedEth += borrowedEth;

            console.log("Send stETH %s, get %s ETH", stethAmount/ 1e18, borrowedEth / 1e18);

            uint256 stethSharesBefore = STETH.sharesOf(address(this));

            position.stvShares += WRAPPER.depositForStrategy{value: borrowedEth}();
            _mintableStethShares = WRAPPER.mintableStethShares(address(this));
            position.stShares += _mintableStethShares;
        }



        console.log("Execute end---");
    }

    function requestWithdrawByETH(address _user, uint256 _stvShares) external returns (uint256 requestId) {}

    function finalizeWithdrawal(address _receiver, uint256 stETHAmount) external returns(uint256 stvToken) {

        
    }
 
    function finalizeWithdrawal(uint256 shares) external returns(uint256 stvToken) {}
    function getWithdrawableEth(address _address) external view returns (uint256 ethAmount) {}


    function _onlyWrapper() internal view {
        if (msg.sender != address(WRAPPER)) revert InvalidWrapper();
    }
}