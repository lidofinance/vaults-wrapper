// SPDX-License-Identifier: MIT
pragma solidity >=0.8.25;

import {IStrategy} from "../interfaces/IStrategy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IStETH} from "../interfaces/IStETH.sol";
import {WrapperC} from "../WrapperC.sol";
import {IVaultHub} from "../interfaces/IVaultHub.sol";
import {IDashboard} from "../interfaces/IDashboard.sol";
import {LenderMock} from 'src/mock/LenderMock.sol';

error NoStETHAvailableForLeverage();


contract LoopStrategy is IStrategy {
    IERC20 public immutable STV_TOKEN;
    IStETH public immutable STETH;
    LenderMock public immutable LENDER_MOCK;

    WrapperC public WRAPPER;

    struct UserPosition {
        address user;
        uint256 stv;
        uint256 stShares;
        uint256 borrowedEth;
    }

    mapping(address => UserPosition) public userPositions;

    uint256 public immutable LOOPS;

    constructor(address _stETH, uint256 _loops) {
        STETH = IStETH(_stETH);
//        STV_TOKEN = IERC20(_wrapper);

        LOOPS = _loops;

        LENDER_MOCK = new LenderMock(_stETH);
    }

    function initialize(address _wrapper) external {
        WRAPPER = WrapperC(payable(_wrapper));
    }

    function strategyId() external pure override returns (bytes32) {
        return keccak256("ExampleLoopStrategy");
    }

    function getUserPosition(address _address) external view returns (UserPosition memory) {
        return userPositions[_address];
    }

    function execute(address _user, uint256 _stv) external {
        uint256 _mintableStShares = WRAPPER.mintableStethShares(address(this));

        UserPosition memory position = userPositions[_user];
        position.stv += _stv;
        position.stShares += _mintableStShares;

        uint256 mintableStShares = _mintableStShares;
        uint256 borrowedEth = 0;
        for (uint256 i = 0; i < LOOPS; i++) {
            WRAPPER.mintStethShares(mintableStShares);
            position.stShares += _mintableStShares;

            borrowedEth = _borrowFromPool(STETH.getPooledEthByShares(mintableStShares));
            position.borrowedEth += borrowedEth;

            uint256 stSharesBefore = STETH.balanceOf(address(this));
            uint256 mintedStv = WRAPPER.depositETH{value: borrowedEth}(address(this), address(0), 0);
            position.stv += mintedStv;
            mintableStShares = STETH.balanceOf(address(this)) - stSharesBefore;
        }

        // Save user position with loop information
        userPositions[_user] = position;
    }

    function _borrowFromPool(uint256 _stethCollateral) internal returns (uint256 borrowedEth) {
        STETH.approve(address(LENDER_MOCK), _stethCollateral);

        uint256 ethBefore = address(this).balance;
        LENDER_MOCK.borrow(_stethCollateral);

        borrowedEth = address(this).balance - ethBefore;
    }

    receive() external payable {}

    function _getStvWithdrawableWithoutBurningStShares(address _address) internal view returns (uint256 stv) {
        UserPosition memory position = userPositions[_address];
        stv = position.stv; // TODO: calc properly
    }

    function requestWithdrawByETH(address _user, uint256 _stv) external override returns (uint256 requestId) {
        // LENDER_MOCK.giveBack{value: address(this).balance}();
        // return WRAPPER.requestWithdrawal(_stv);
        uint256 stv = _getStvWithdrawableWithoutBurningStShares(_user);
       return WRAPPER.requestWithdrawalQueue(msg.sender, msg.sender, stv);
    }

    function finalizeWithdrawal(address _receiver, uint256 stETHAmount) external returns(uint256 stvToken) {}
    function getWithdrawableEth(address _address) external view returns (uint256 ethAmount) {}
}
